// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "component_integrity.hpp"

#include <algorithm>
#include <array>
#include <iostream>
#include <memory>
#include <phosphor-logging/elog-errors.hpp>
#include <phosphor-logging/elog.hpp>
#include <phosphor-logging/log.hpp>
#include <sdbusplus/bus.hpp>
#include <sdbusplus/exception.hpp>
#include <sdbusplus/message.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

extern "C" {
#include "spdm_conn.h"
}

// TODO(b/346419147)
// choice of which L1L2 buffer to use:
//   option 1) L1L2 recorded with msg log interface or
//   option 2) by cloning the L1L2 buffer generated by libspdm.
// option 1 can be done fully within libspdmwrapper, while
// option 2 requires modify libspdm to add a hook to clone L1L2, thus more
// intrusive to libspdm.
// In theory, both options should be OK, but we have doubts about option1's
// correctness.
#define USE_CLONE_L1L2

namespace phosphor::component_integrity {
namespace {
using ::phosphor::logging::level;
using ::phosphor::logging::log;
using ::sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument;
using AssociationList =
    std::vector<std::tuple<std::string, std::string, std::string>>;
}  // namespace

ComponentIntegrity::ComponentIntegrity(
    sdbusplus::bus::bus& bus, const char* path, bool componentIntegrityEnabled,
    spdm_conn_t* spdm_conn,
    const sdbusplus::xyz::openbmc_project::Attestation::server::ComponentIntegrity::
        SecurityTechnologyType protocolType,
    const std::string& protocolTypeVersion, const uint64_t updatedTime,
    sdbusplus::xyz::openbmc_project::Attestation::server::
        IdentityAuthentication::VerificationStatus status)
    : internal::ComponentIntegrityInterface(bus, path, action::defer_emit) {
  this->enabled(componentIntegrityEnabled);
  this->type(protocolType);
  this->typeVersion(protocolTypeVersion);
  this->lastUpdated(updatedTime);
  this->responderVerificationStatus(status);
  this->spdm_conn = spdm_conn;

  log<level::INFO>("ComponentIntegrity Instance Created!");
}

ComponentIntegrity::~ComponentIntegrity() {
  log<level::INFO>("ComponentIntegrity Instance Destroyed!");
}

uint8_t hex2byte(char c) {
  if (c >= '0' && c <= '9')
    return (uint8_t)(c - '0');
  else if (c >= 'a' && c <= 'f')
    return (uint8_t)(c - 'a') + 10;
  else if (c >= 'A' && c <= 'F')
    return (uint8_t)(c - 'A') + 10;
  else
    throw std::invalid_argument("Invalid hex string");
}

static const char b64_alphabet[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

std::string base64_encode(const std::string& input) {
  std::string output;
  int val = 0, valb = -6;
  for (unsigned char c : input) {
    val = (val << 8) + c;
    valb += 8;
    while (valb >= 0) {
      output.push_back(b64_alphabet[(val >> valb) & 0x3F]);
      valb -= 6;
    }
  }
  if (valb > -6) {
    output.push_back(b64_alphabet[(val << 8) >> (valb + 8) & 0x3F]);
  }
  while (output.size() % 4) {
    output.push_back('=');
  }
  return output;
}

std::tuple<sdbusplus::message::object_path, std::string, std::string,
           std::string, std::string, std::string>
ComponentIntegrity::spdmGetSignedMeasurements(
    std::vector<size_t> measurementIndices, std::string nonce, size_t slotId) {
  int i;
  libspdm_return_t status;
  sdbusplus::message::object_path certificate("Invalid DeviceCert!");
  std::string hashingAlg("Invalid HASH Algorithm!");
  std::string signedAlg("Invalid Signing Algorithm!");
  std::string version("Invalid Version!");
  std::string signedMeasurements("Invalid Measurements!");

  // Note, we donot set PUBKEY as it should be extracted from the certificate.
  std::string pubKey("PUBKEY can be extracted from certificate!");

  // set certificate path from associations
  bool found = false;
  auto assocs = this->associations();
  for (auto iter = assocs.begin(); iter != assocs.end(); ++iter) {
    if (std::get<0>(*iter).compare("responder_identified_by") == 0) {
      certificate = std::string(std::get<2>(*iter));
      found = true;
      break;
    }
  }

  if (!found) {
    log<level::ERR>("[ComponentIntegrity] Device cert not found!");
    auto response = make_tuple(certificate, hashingAlg, pubKey,
                               signedMeasurements, signedAlg, version);
    return response;
  }

  // SPDM version
  if (this->spdm_conn->m_use_version == SPDM_MESSAGE_VERSION_10)
    version = std::string("1.0");
  else if (this->spdm_conn->m_use_version == SPDM_MESSAGE_VERSION_11)
    version = std::string("1.1");
  else if (this->spdm_conn->m_use_version == SPDM_MESSAGE_VERSION_12)
    version = std::string("1.2");
  else if (this->spdm_conn->m_use_version == SPDM_MESSAGE_VERSION_13)
    version = std::string("1.3");
  else {
    log<level::ERR>("[ComponentIntegrity] Unsupported SPDM Version!");
    auto response = make_tuple(certificate, hashingAlg, pubKey,
                               signedMeasurements, signedAlg, version);
    return response;
  }

  // Get Hashing Alg
  // Based on
  // https://github.com/DMTF/Redfish/blob/master/metadata/ComponentIntegrity_v1.xml
  // it "shall be the hash algorithm names found in the 'BaseHashAlgo'
  // field of the 'NEGOTIATE_ALGORITHMS' request message in DSP0274.
  switch (this->spdm_conn->m_use_hash_algo) {
    case SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_512:
      hashingAlg = std::string("TPM_ALG_SHA_512");
      break;
    case SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384:
      hashingAlg = std::string("TPM_ALG_SHA_384");
      break;
    case SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256:
      hashingAlg = std::string("TPM_ALG_SHA_256");
      break;
    case SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_512:
      hashingAlg = std::string("TPM_ALG_SHA3_512");
      break;
    case SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_384:
      hashingAlg = std::string("TPM_ALG_SHA3_384");
      break;
    case SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_256:
      hashingAlg = std::string("TPM_ALG_SHA3_256");
      break;
    default:
      log<level::ERR>("[ComponentIntegrity] Unsupported HASH Algorithm!");
      auto response = make_tuple(certificate, hashingAlg, pubKey,
                                 signedMeasurements, signedAlg, version);
      return response;
  }

  // Signed Algorithm
  switch (this->spdm_conn->m_use_asym_algo) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
      signedAlg = std::string("TPM_ALG_ECDSA_ECC_NIST_P384");
      break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
      signedAlg = std::string("TPM_ALG_ECDSA_ECC_NIST_P256");
      break;
    default:
      log<level::ERR>("[ComponentIntegrity] Unsupported Signing Algorithm!");
      auto response = make_tuple(certificate, hashingAlg, pubKey,
                                 signedMeasurements, signedAlg, version);
      return response;
  }

  /* hexstring to byte array: two hex char map to 1 byte */
  if (nonce.size() != SPDM_NONCE_SIZE * 2) {
    log<level::ERR>("[ComponentIntegrity] Unsupported nonce size!");
    auto response = make_tuple(certificate, hashingAlg, pubKey,
                               signedMeasurements, signedAlg, version);
    return response;
  }

  // Handle allocation error
  try {
    std::unique_ptr<size_t[]> indices =
      std::make_unique<size_t[]>(measurementIndices.size());

    for (i = 0; i < measurementIndices.size(); i++)
      indices[i] = measurementIndices[i];

    std::unique_ptr<uint8_t[]> nonce_in=
      std::make_unique<uint8_t[]>(nonce.size() / 2);

    for (i = 0; i < nonce.size() / 2; i++)
      nonce_in[i] = hex2byte(nonce[i * 2]) << 4 | hex2byte(nonce[i * 2 + 1]);

    // No need to return measurement blocks, all stored in L2 log.
    status = spdm_cma_get_signed_measurements(this->spdm_conn, slotId,
               nonce_in.get(), indices.get(), measurementIndices.size());
    if (LIBSPDM_STATUS_IS_ERROR(status)) {
      log<level::ERR>("[ComponentIntegrity] get measurements failed!");
      auto response = make_tuple(certificate, hashingAlg, pubKey,
                                 signedMeasurements, signedAlg, version);
      return response;
    } else {
    // we have two source for L1L2, one is recorded with msg log, the other is
    // a copy of L1L2 transcript recorded by libspdm.
#ifdef USE_CLONE_L1L2
      uint8_t* l1l2 =
        (uint8_t*)libspdm_get_managed_buffer(&this->spdm_conn->clone_l1l2);
      size_t l1l2_size =
        libspdm_get_managed_buffer_size(&this->spdm_conn->clone_l1l2);
#else
      uint8_t* l1l2 = (uint8_t*)libspdm_get_managed_buffer(&this->spdm_conn->l1l2);
      size_t l1l2_size = libspdm_get_managed_buffer_size(&this->spdm_conn->l1l2);
#endif

      std::string bin_l1l2;
      bin_l1l2.assign(l1l2, l1l2 + l1l2_size);
      signedMeasurements = base64_encode(bin_l1l2);
    }
  } catch (const std::bad_alloc& e) {
    log<level::ERR>("[ComponentIntegrity] bad alloc!");
  }

  auto response = make_tuple(certificate, hashingAlg, pubKey,
                             signedMeasurements, signedAlg, version);
  return response;
}

}  // namespace phosphor::component_integrity
